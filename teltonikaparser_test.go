// Copyright 2019 Filip Kroƒça. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package teltonikaparser

import (
	"encoding/hex"
	"fmt"
	"testing"
)

const testDataString string = "04F6CAFE012C000F333532303934303835313232343532081B0000016C1E168327000A688C7A1D2CA01900D1014E0D001BF70401F7050311FF7612FFFB13FE4A00000000016C1E168331000A688C7A1D2CA01900D1014E0D001BF70401F7050311FFC412FFE813FE8A00000000016C1E16833B000A688C7A1D2CA01900D1014E0D001BF70401F7050311FF4112FFDD13003F00000000016C1E168345000A688C7A1D2CA01900D1014E0D001BF70401F7050311FF5112FFC61300DF00000000016C1E16834F000A688C7A1D2CA01900D1014E0D001BF70401F7050311002812005013FEA700000000016C1E168359000A688C7A1D2CA01900D1014E0D001BF70401F7050311005112005013FE8800000000016C1E1753C8000A67F9DD1D2D5CA400BD00120E002100160AEF01F00150011503C800450101007155FB00F6000CB50007B600034235AD180021CD3CC4CE6064430F7544000011FF431200C813FB6C0F03E800000000016C1E168363000A688C7A1D2CA01900D1014E0D001BF70401F7050311002E12007513FF0600000000016C1E16836D000A688C7A1D2CA01900D1014E0D001BF70401F7050311000A12FF9713FFF700000000016C1E168377000A688C7A1D2CA01900D1014E0D001BF70401F705031100A312000013013500000000016C1E168381000A688C7A1D2CA01900D1014E0D001BF70401F7050311FFAC12FFA413FF1000000000016C1E16838B000A688C7A1D2CA01900D1014E0D001BF70401F7050311FEFC12FF9113FE0D00000000016C1E168395000A688C7A1D2CA01900D1014E0D001BF70401F705031100A312007D13FF2A00000000016C1E16839F000A688C7A1D2CA01900D1014E0D001BF70401F705031100321200411305BC00000000016C1E1683A9000A688C7A1D2CA01900D1014E0D001BF70401F7050311FE9012FE9B13FE1500000000016C1E1683B3000A688C7A1D2CA01900D1014E0D001BF70401F705031100B012000313FE2100000000016C1E1683BD000A688C7A1D2CA01900D1014E0D001BF70401F7050311007F1200BE13035700000000016C1E1683C7000A688C7A1D2CA01900D1014E0D001BF70401F7050311FF1612FFE713FF8200000000016C1E1757B0000A67F9DD1D2D5CA400BD00120E0021FD180CEF01F00150011503C800450101007154FB00FD03F600FE2E0CB50007B600034235CA180021CD3CC4CE6064430F7044000011FF2812016B13FB5E0F03E800000000016C1E1683D1000A688C7A1D2CA01900D1014E0D001BF70401F7050311005612FF4913FD7800000000016C1E1683DB000A688C7A1D2CA01900D1014E0D001BF70401F705031101DB12006E13FE0D00000000016C1E1683E5000A688C7A1D2CA01900D1014E0D001BF70401F7050311FEA312008413FF2800000000016C1E1683EF000A688C7A1D2CA01900D1014E0D001BF70401F7050311011C12001313FF3A00000000016C1E1757BA000A67FC351D2D5F2E00BF00230E001F00160AEF01F00150011503C800450101007154FB00F6000CB50007B600034235CD18001FCD3CC4CE6064430F6F44000011FF2812016B13FB5E0F03E800000000016C1E1683F9000A688C7A1D2CA01900D1014E0D001BF70401F7050311FE4212FFEC13FDE000000000016C1E168403000A688C7A1D2CA01900D1014E0D001BF70401F7050311011512005413FD8700000000016C1E16840D000A688C7A1D2CA01900D1014E0D001BF70401F7050311008212004313FEA000001B"

func TestParseIMEI(t *testing.T) {
	//sample data
	bs, _ := hex.DecodeString(testDataString)

	//run test
	imei, err := ParseIMEI(&bs)
	if err != nil {
		t.Errorf("TestParseIMEI() Error when parsing IMEI %v", err)
	}

	if imei != uint64(352094085122452) {
		t.Errorf("TestParseIMEI([]byte) want 352094085122452, got %v ", imei)
	}

}

func TestParseHex2Int32TwoComplement(t *testing.T) {
	bs := []byte{0xE2, 0xD3, 0x5F, 0xE7}

	//run test
	decoded := ParseHex2Int32TwoComplement(&bs, 0, 4)

	if decoded != -489463833 {
		t.Errorf("TestParseHex2Uint64() Error when parsing 0x20,0x9A,0x69,0x00 want 546990336, got %v", decoded)
	}

}

func ExampleParseHex2Int32TwoComplement() {
	bs := []byte{0xE2, 0xD3, 0x5F, 0xE7}

	//run test
	decoded := ParseHex2Int32TwoComplement(&bs, 0, 4)

	fmt.Println(decoded)
	// Output:
	// -489463833

}

func BenchmarkParseHex2Int32TwoComplement(b *testing.B) {
	bs := []byte{0xE2, 0xD3, 0x5F, 0xE7}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ParseHex2Int32TwoComplement(&bs, 0, 4)
	}
}

func ExampleParseIMEI() {
	//sample data
	bs, _ := hex.DecodeString(testDataString)
	imei, _ := ParseIMEI(&bs)
	fmt.Println(imei)
	// Output:
	// 352094085122452
}

func TestParseHex2Uint64(t *testing.T) {
	bs := []byte{0x20, 0x9A, 0x69, 0x00}

	//run test
	decoded := ParseHex2Uint64(&bs, 0, 4)

	if decoded != uint64(546990336) {
		t.Errorf("TestParseHex2Uint64() Error when parsing 0x20,0x9A,0x69,0x00 want 546990336, got %v", decoded)
	}

}

func BenchmarkParseIMEI(b *testing.B) {
	//sample data
	bs, _ := hex.DecodeString(testDataString)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ParseIMEI(&bs)
	}
}

func BenchmarkHex2Uint64(b *testing.B) {
	bs := []byte{0x20, 0x9A, 0x69, 0x00}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ParseHex2Uint64(&bs, 0, 3)
	}
}

func BenchmarkDecode(b *testing.B) {
	bs, _ := hex.DecodeString(testDataString)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Decode(&bs)
	}
}
